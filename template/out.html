{% extends "base.html" %}

{% block content %}
<h1>Developer's Guide<img src='https://cdn.rawgit.com/miyuchina/mistletoe/master/resources/logo.svg' align='right' width='128' height='128'></h1>
<p>This document describes usage of mistletoe and its API
from the developer's point of view.</p>
<h2>Understanding the AST and the tokens</h2>
<p>When a markdown document gets parsed by mistletoe, the result is represented
as an <em>abstract syntax tree (AST)</em>, stored in an instance of <code>Document</code>.
This object contains a hierarchy of all the various <em>tokens</em> which were recognized
during the parsing process, for example, <code>Paragraph</code>, <code>Heading</code>, and <code>RawText</code>.</p>
<p>The tokens which represent a line or a block of lines in the input markdown
are called <em>block tokens</em>. Examples include <code>List</code>, <code>Paragraph</code>, <code>ThematicBreak</code>,
and also the <code>Document</code> itself.</p>
<p>The tokens which represent the actual content within a block are called <em>span tokens</em>,
or, with CommonMark terminology, <em>inline tokens</em>.
In this category you will find tokens like <code>RawText</code>, <code>Link</code>, and <code>Emphasis</code>.</p>
<p>Block tokens may have block tokens, span tokens, or no tokens at all as children
in the AST; this depends on the type of token. Span tokens may <em>only</em> have span
tokens as children.
Every token has properties called <code>children</code> and <code>parent</code> that can be used
for traversing the nodes hierarchy.</p>
<h3>Viewing the AST</h3>
<p>In order to see what exactly gets parsed, one can simply use the <code>AstRenderer</code>
on a given markdown input, for example:</p>
<pre><code class="language-sh">mistletoe text.md --renderer mistletoe.ast_renderer.AstRenderer
</code></pre>
<p>Say that the input file contains for example:</p>
<pre><code class="language-markdown"># Heading 1

text

# Heading 2

[link](https://www.example.com)
</code></pre>
<p>Then we will get this JSON output from the AST renderer:</p>
<pre><code class="language-json">{
  "type": "Document",
  "footnotes": {},
  "line_number": 1,
  "children": [
    {
      "type": "Heading",
      "line_number": 1,
      "level": 1,
      "children": [
        {
          "type": "RawText",
          "content": "Heading 1"
        }
      ]
    },
    {
      "type": "Paragraph",
      "line_number": 3,
      "children": [
        {
          "type": "RawText",
          "content": "text"
        }
      ]
    },
    {
      "type": "Heading",
      "line_number": 5,
      "level": 1,
      "children": [
        {
          "type": "RawText",
          "content": "Heading 2"
        }
      ]
    },
    {
      "type": "Paragraph",
      "line_number": 7,
      "children": [
        {
          "type": "Link",
          "target": "https://www.example.com",
          "title": "",
          "children": [
            {
              "type": "RawText",
              "content": "link"
            }
          ]
        }
      ]
    }
  ]
}
</code></pre>
<h3>Line numbers</h3>
<p>mistletoe records the starting line of all block tokens that it encounters during
parsing and stores it as the <code>line_number</code> attribute of each token.
(This feature is not available for span tokens yet.)</p>
<h2>Rendering</h2>
<p>Sometimes all you need is the information from the AST. But more often, you'll
want to take that information and turn it into some other format like HTML.
This is called <em>rendering</em>. mistletoe provides a set of built-in renderers for
different formats, and it's also possible to define your own renderer.</p>
<p>When passing an AST to a renderer, the tree is recursively traversed
and methods corresponding to individual token types get called on the renderer
in order to create the output in the desired format.</p>
<h2>Creating a custom token and renderer</h2>
<p>Here's an example of how to add GitHub-style wiki links to the parsing process,
and provide a renderer for this new token.</p>
<h3>A new token</h3>
<p>GitHub wiki links are span-level tokens, meaning that they reside inline,
and don't really look like chunky paragraphs. To write a new span-level
token, all we need to do is make a subclass of <code>SpanToken</code>:</p>
<pre><code class="language-python">from mistletoe.span_token import SpanToken

class GithubWiki(SpanToken):
    pass
</code></pre>
<p>mistletoe uses regular expressions to search for span-level tokens in the
parsing process. As a refresher, GitHub wiki looks something like this:
<code>[[alternative text | target]]</code>. We define a class variable, <code>pattern</code>,
that stores the compiled regex:</p>
<pre><code class="language-python">class GithubWiki(SpanToken):
    pattern = re.compile(r"\[\[ *(.+?) *\| *(.+?) *\]\]")
    def __init__(self, match):
        pass
</code></pre>
<p>The regex will be picked up by <code>SpanToken.find</code>, which is used by the
tokenizer to find all tokens of its kind in the document.
If regexes are too limited for your use case, consider overriding
the <code>find</code> method; it should return a list of all token occurrences.</p>
<p>Three other class variables are available for our custom token class,
and their default values are shown below:</p>
<pre><code class="language-python">class SpanToken:
    parse_group = 1
    parse_inner = True
    precedence = 5
</code></pre>
<p>Note that alternative text can also contain other span-level tokens. For
example, <code>[[*alt*|link]]</code> is a GitHub link with an <code>Emphasis</code> token as its
child. To parse child tokens, <code>parse_inner</code> should be set to <code>True</code>
(the default value in this case), and <code>parse_group</code> should correspond
to the match group in which child tokens might occur
(also the default value, 1, in this case).</p>
<p>Once these two class variables are set correctly,
<code>GithubWiki.children</code> attribute will automatically be set to
the list of child tokens.
Note that there is no need to manually set this attribute,
unlike previous versions of mistletoe.</p>
<p>Lastly, the <code>SpanToken</code> constructors take a regex match object as its argument.
We can simply store off the <code>target</code> attribute from <code>match_obj.group(2)</code>.</p>
<pre><code class="language-python">from mistletoe.span_token import SpanToken

class GithubWiki(SpanToken):
    pattern = re.compile(r"\[\[ *(.+?) *\| *(.+?) *\]\]")
    def __init__(self, match_obj):
        self.target = match_obj.group(2)
</code></pre>
<p>There you go: a new token in 5 lines of code.</p>
<h3>Side note about precedence</h3>
<p>Normally there is no need to override the <code>precedence</code> value of a custom token.
The default value is the same as <code>InlineCode</code>, <code>AutoLink</code> and <code>HtmlSpan</code>,
which means that whichever token comes first will be parsed. In our case:</p>
<pre><code class="language-markdown">`code with [[ text` | link ]]
</code></pre>
<p>... will be parsed as:</p>
<pre><code class="language-html">&lt;code&gt;code with [[ text&lt;/code&gt; | link ]]
</code></pre>
<p>If we set <code>GithubWiki.precedence = 6</code>, we have:</p>
<pre><code class="language-html">`code with &lt;a href="link"&gt;text`&lt;/a&gt;
</code></pre>
<h3>A new renderer</h3>
<p>Adding a custom token to the parsing process usually involves a lot
of nasty implementation details. Fortunately, mistletoe takes care
of most of them for you. Simply passing your custom token class to
<code>super().__init__()</code> does the trick:</p>
<pre><code class="language-python">from mistletoe.html_renderer import HtmlRenderer

class GithubWikiRenderer(HtmlRenderer):
    def __init__(self):
        super().__init__(GithubWiki)
</code></pre>
<p>We then only need to tell mistletoe how to render our new token:</p>
<pre><code class="language-python">def render_github_wiki(self, token):
    template = '&lt;a href="{target}"&gt;{inner}&lt;/a&gt;'
    target = token.target
    inner = self.render_inner(token)
    return template.format(target=target, inner=inner)
</code></pre>
<p>Cleaning up, we have our new renderer class:</p>
<pre><code class="language-python">from mistletoe.html_renderer import HtmlRenderer, escape_url

class GithubWikiRenderer(HtmlRenderer):
    def __init__(self):
        super().__init__(GithubWiki)

    def render_github_wiki(self, token):
        template = '&lt;a href="{target}"&gt;{inner}&lt;/a&gt;'
        target = escape_url(token.target)
        inner = self.render_inner(token)
        return template.format(target=target, inner=inner)
</code></pre>
<h3>Take it for a spin?</h3>
<p>It is preferred that all mistletoe's renderers be used as context managers.
This is to ensure that your custom tokens are cleaned up properly, so that
you can parse other Markdown documents with different token types in the
same program.</p>
<pre><code class="language-python">from mistletoe import Document
from contrib.github_wiki import GithubWikiRenderer

with open('foo.md', 'r') as fin:
    with GithubWikiRenderer() as renderer:
        rendered = renderer.render(Document(fin))
</code></pre>
<p>For more info, take a look at the <code>base_renderer</code> module in mistletoe.
The docstrings might give you a more granular idea of customizing mistletoe
to your needs.</p>
<h2>Markdown to Markdown parsing-and-rendering</h2>
<p>Suppose you have some Markdown that you want to process and then output
as Markdown again. Thanks to the text-like nature of Markdown, it is often
possible to do this with text search-and-replace tools... but not always. For
example, if you want to replace a text fragment in the plain text, but not
in the embedded code samples, then the search-and-replace approach won't work.</p>
<p>In this case you can use mistletoe's <code>MarkdownRenderer</code>:</p>
<ol>
<li>Parse Markdown to an AST (usually held in a <code>Document</code> token).</li>
<li>Make modifications to the AST.</li>
<li>Render back to Markdown using <code>MarkdownRenderer.render()</code>.</li>
</ol>
<p>Here is an example of how you can replace text in selected parts of the AST:</p>
<pre><code class="language-python">import mistletoe
from mistletoe.block_token import BlockToken, Heading, Paragraph, SetextHeading
from mistletoe.markdown_renderer import MarkdownRenderer
from mistletoe.span_token import InlineCode, RawText, SpanToken

def update_text(token: SpanToken):
    """Update the text contents of a span token and its children.
    `InlineCode` tokens are left unchanged."""
    if isinstance(token, RawText):
        token.content = token.content.replace("mistletoe", "The Amazing mistletoe")

    if not isinstance(token, InlineCode) and hasattr(token, "children"):
        for child in token.children:
            update_text(child)

def update_block(token: BlockToken):
    """Update the text contents of paragraphs and headings within this block,
    and recursively within its children."""
    if isinstance(token, (Paragraph, SetextHeading, Heading)):
        for child in token.children:
            update_text(child)

    for child in token.children:
        if isinstance(child, BlockToken):
            update_block(child)

with open("README.md", "r") as fin:
    with MarkdownRenderer() as renderer:
        document = mistletoe.Document(fin)
        update_block(document)
        md = renderer.render(document)
        print(md)
</code></pre>
<p>The <code>MarkdownRenderer</code> can also reflow the text in the document to a given
maximum line length. And it can do so while preserving the formatting of code
blocks and other tokens where line breaks matter. To use this feature,
specify a <code>max_line_length</code> parameter in the call to the <code>MarkdownRenderer</code>
constructor.</p>

{% endblock content %}